"""
    parameterDictionary(net, inheritancecorrelation; tauSymbol="", gammaSymbol="")

Creates a dictionary mapping parameter labels to values (edge lengths and inheritance probabilities) in a network.

## Description
This function generates a dictionary where:
- **Edge lengths (`τ`)** are assigned symbolic labels (`t_{i}`).
- **Inheritance probabilities (`γ`)** are assigned symbolic labels (`r_{j}`).
- **Inheritance correlation (`ρ`)** is included as `&rho`, along with `1 - ρ`.

For merged edges, symbolic names are assigned based on `mergedEdgeLengthandSymbolicName`.

## Arguments
- `net`: The input PhyloNetworks `HybridNetwork` object.
- `inheritancecorrelation`: The inheritance correlation value, which is rounded and assigned a symbolic label.
- `tauSymbol`: (Optional) Custom prefix for edge length symbols. Default is `"t_"`. [to be added in future versions]
- `gammaSymbol`: (Optional) Custom prefix for inheritance probability symbols. Default is `"r_"`. [to be added in future versions]

## Returns
- A `Dict{Any, String}` mapping numerical values to symbolic parameter labels.
"""
function parameterDictionary(net, inheritancecorrelation; tauSymbol::String="t_", gammaSymbol::String="r_")
    dict = Dict()
    # Dictionary for edge lengths (τ)
    numEdges = length(net.edge)
    allNetEdges = collect(1:numEdges)
    termedgenum = [e.number for e in net.edge if PhyloNetworks.getchild(e).leaf]
    maxMergedEdges = net.numTaxa + 2*(net.numHybrids) #max_edges_from_leaf_to_leaf(net)-2
    for mergeRange in 1:maxMergedEdges
        if mergeRange == 1
            for e in allNetEdges
                dict[net.edge[e].length] = "$tauSymbol{$e}"
            end
        else
            edgeCombinations = collect(combinations(allNetEdges, mergeRange))
            for edgeCombo in edgeCombinations
                if isempty(intersect(edgeCombo, termedgenum))
                    length, symbolicName = mergedEdgeLengthandSymbolicName(net, edgeCombo)
                    dict[length] = symbolicName
                end
            end
        end
    end
    # Dictionary for inheritance probabilities (γ)
    hybridNodeNumbers = [n.number for n in net.node if n.hybrid]
    for j in 1:net.numHybrids
        hybNode = hybridNodeNumbers[j]
        visitCount = 1
        for e in net.edge
            if PhyloNetworks.getchild(e).number == hybNode
                e.gamma = round(e.gamma, digits=dpoints)
                if visitCount == 1
                    dict[e.gamma] = "$gammaSymbol{$j}"
                    visitCount += 1
                elseif visitCount == 2
                    dict[e.gamma] = "(1-$gammaSymbol{$j})"
                else
                    error("Hybrid node $(hybNode) has more than 2 incoming edges.")
                end
            end
        end
    end
    # Inheritance correlation (ρ)
    inheritancecorrelation = round(inheritancecorrelation, digits=dpoints)
    dict[inheritancecorrelation] = "&rho"
    dict[round(1 - inheritancecorrelation, digits=dpoints)] = "1-&rho"
    return dict
end

"""
    mergedEdgeLengthandSymbolicName(net::HybridNetwork, edgevec::Vector{Int})

Computes the total edge length and generates a symbolic name for a given set of edges.

## Description
Given a vector of edge indices (`edgevec`) in a `HybridNetwork`, this function:
- **Sums** the lengths of the specified edges.
- **Constructs a symbolic name** in the form `"-t_{e1}-t_{e2}..."`.

## Arguments
- `net`: A `HybridNetwork` object.
- `edgevec`: A vector containing edge indices.

## Returns
- length and symbolicName where:
  - `length` is the total length of the selected edges (rounded to `dpoints`).
  - `symbolicName` is a concatenated symbolic representation of these edges.
"""
function mergedEdgeLengthandSymbolicName(net::HybridNetwork, edgevec::Vector{Int})
    total_length = sum(net.edge[e].length for e in edgevec)
    symbolic_name = join(["-t_{$e}" for e in edgevec])
    symbolic_name=chop(symbolic_name,head=1,tail=0)#remove the very first "-"
    total_length = round(total_length, digits=dpoints)
    return total_length, symbolic_name
end

"""
    gettingSymbolicTopology(net::HybridNetwork, dict::Dict)

Replaces numeric parameter values with symbolic representations in an extended Newick string.

## Description
This function converts a `HybridNetwork` topology into an **extended Newick format** where:
- Edge lengths are replaced by symbols of the form `"t_{e}"`.
- Inheritance probabilities (`γ`) are replaced using their corresponding symbolic values from `dict`.

## Arguments
- `net`: A `HybridNetwork` object.
- `dict`: A dictionary mapping numerical values to symbolic labels.

## Returns
- A string representing the network in symbolic extended Newick format.
"""
function gettingSymbolicTopology(net::HybridNetwork, dict::Dict)
    eNewick=PN.writeTopology(net)
    for e in net.edge 
        eNewick=replace(eNewick,"$(e.length)"=>"t_{$(e.number)}")
        eNewick=replace(eNewick,"$(e.gamma)"=>"$(dict[e.gamma])")
    end
    return eNewick
end
    
"""
    gettingSymbolicInput(net::HybridNetwork, df, inheritancecorrelation)

Transforms numerical values in the concordance factor (CF) equations into symbolic representations.

## Description
This function updates a dataframe (`df`) containing CF equations by replacing:
- The inheritance correlation `"rho"` with its numerical value.
- Edge-related terms `"-t_{e}"` with `"X{e}"`.
- Hybrid-related terms `"r_{e}"` with `"R{e}"`.
- Exponential terms `"exp(-t_{e})"` into `"(X{e}"`.
- Other symbolic replacements for consistency.

Additionally, it extracts and returns a **sorted list of unique symbolic parameters** used in the CF equations.

## Arguments
- `net`: A `HybridNetwork` object.
- `df`: A dataframe containing CF equations.
- `inheritancecorrelation`: The numerical value of the inheritance correlation.

## Returns
- A sorted vector of unique symbolic parameters used in the CF equations.
"""   
function gettingSymbolicInput(net::HybridNetwork, df, inheritancecorrelation)
    edgenumber = length(net.edge)
    retnumber = length(net.hybrid)
    numCFs = size(df, 1)
    
    params = String[]

    for i in 1:numCFs
        df[i, 2] = replace(df[i, 2], "rho" => "$inheritancecorrelation")
        record = false
        expressions = String[]

        for e in 1:edgenumber
            if occursin("-t_{$e}", df[i, 2])
                push!(expressions, "X$e")
            end
        end

        for e in 1:retnumber
            if occursin("r_{$e}", df[i, 2])
                push!(expressions, "R$e")
            end
        end    

        append!(params, expressions)
    end

    params = unique(params)

    # Replace symbolic expressions in CF equations
    for cf in 1:numCFs
        df[cf, 2] = replace(df[cf, 2], "r_{" => "R")   # Replace hybrid parameter notation
        df[cf, 2] = replace(df[cf, 2], "exp(-t_{" => "(X")  # Replace exponential notation
        df[cf, 2] = replace(df[cf, 2], "-t_{" => "*X")  # Replace edge length notation
        df[cf, 2] = replace(df[cf, 2], "})" => ")")     # Close parentheses
        df[cf, 2] = replace(df[cf, 2], "}" => "")       # Remove extra braces
    end

    return sort!(params)
end
    
"""
    makeEdgeLabel(net; showTerminalEdgeLabels=false)

Generates a dataframe mapping edge numbers to their symbolic labels.

## Description
This function creates labels for the edges of a `HybridNetwork` in the format `"t_{e}"`, where `e` is the edge number.  
By default, labels are only assigned to **non-terminal edges** (i.e., edges that do not end at leaf nodes).  
The output dataframe is used as input for PhyloPlots' option `edgelabel=``.
Setting `showTerminalEdgeLabels=true` includes labels for terminal edges as well.

## Arguments
- `net`: A `HybridNetwork` object.
- `showTerminalEdgeLabels`: A boolean flag (default = `false`).  
   - `false`: Excludes terminal edges.  
   - `true`: Includes all edges.  

## Returns
- A `DataFrame` with columns:
  - `number`: Edge numbers.
  - `label`: Corresponding symbolic labels (`"t_{e}"`).
"""
function makeEdgeLabel(net; showTerminalEdgeLabels=false)
    edges_to_include = [e for e in net.edge if !PhyloNetworks.getchild(e).leaf || showTerminalEdgeLabels]
    df = DataFrame(
        number = [e.number for e in edges_to_include],
        label = ["t_{$(e.number)}" for e in edges_to_include]
    )
    return df
end

function max_edges_from_leaf_to_leaf(net::PhyloNetworks.HybridNetwork)
    # Step 1: Identify leaves and the root
    leaves = PhyloNetworks.Node[]
    for node in net.node
        if node.leaf
            push!(leaves, node)
        end
    end
    root = net.node[net.root]
    
    if isnothing(root)
        error("Root not found in the network")
    end

    # Step 2: Function to count edges from a leaf to the root using getparent
    function edges_to_root(leaf::PhyloNetworks.Node)
        current = leaf
        edge_count = 0
        visited = Set{PhyloNetworks.Node}()
        push!(visited, current)
        path = [current.number]  # Debug path

        while current != root
            parent = nothing
            # Use getparent to move upward; handle major and minor parents for hybrid nodes
            try
                parent = PhyloNetworks.getparent(current)
            catch e
                # If no major parent, try minor parent (for hybrid nodes)
                parent = PhyloNetworks.getparentminor(current) 
            end
            if isnothing(parent)
                #println("Traversal path for leaf $(leaf.number): ", path)
                error("No parent found for node $(current.number) on path from leaf $(leaf.number) to root $(root.number)")
            end
            if parent in visited
                #println("Traversal path for leaf $(leaf.number): ", path)
                error("Cycle detected at node $(parent.number) from leaf $(leaf.number) to root $(root.number)")
            end
            current = parent
            edge_count += 1
            push!(visited, current)
            push!(path, current.number)
        end
        #println("Path from leaf $(leaf.number) to root: ", path)
        return edge_count
    end

    # Step 3: Compute distances for all leaves
    distances = Dict{PhyloNetworks.Node, Int}()
    for leaf in leaves
        dist = edges_to_root(leaf)
        distances[leaf] = dist
        #println("Edges from leaf $(leaf.number) to root: $dist")
    end

    # Step 4: Find maximum sum for all pairs of leaves
    max_sum = 0
    for i in 1:length(leaves)-1
        for j in i+1:length(leaves)
            sum_dist = distances[leaves[i]] + distances[leaves[j]]
            #println("Sum for leaves $(leaves[i].number) and $(leaves[j].number): $sum_dist")
            if sum_dist > max_sum
                max_sum = sum_dist
            end
        end
    end

    return max_sum
end

"""
    network_expectedCF_formulas(network::HybridNetwork; 
                                showprogressbar=true, 
                                inheritancecorrelation=0, 
                                filename="symbolicQNC-HFO-out"::AbstractString, 
                                symbolic=false::Bool, 
                                savecsv=false::Bool, 
                                macaulay=false::Bool, 
                                matlab=false::Bool, 
                                multigraded=false::Bool,
                                singular=false::Bool)

Compute expected concordance factors (CFs) for quartets in a phylogenetic network, optionally generating symbolic formulas.

This function calculates the expected concordance factors (CFs) for all possible quartets of taxa in a `HybridNetwork`, 
taking into account coalescent processes and inheritance correlations at hybrid nodes. It can operate in numerical mode 
(default) or symbolic mode (when `symbolic=true`), where it expresses CFs as formulas involving branch lengths and 
inheritance parameters (γ). Results are logged to a file, and optional outputs can be saved as CSV, Macaulay2, MATLAB, 
or multigraded implicitization files for further analysis.

# Arguments
- `network::HybridNetwork`: A phylogenetic network from the PhyloNetworks package, with edge lengths in coalescent units and γ values for hybrid edges.
- `showprogressbar::Bool=true`: If true, displays a progress bar for quartet calculations.
- `inheritancecorrelation::Number=0`: Correlation between inheritance probabilities at hybrid nodes (must be between 0 and 1).
- `filename::AbstractString="symbolicQNC_HFO_out"`: Base name for output files (e.g., log, CSV, Macaulay2, MATLAB).
- `symbolic::Bool=false`: If true, computes CFs as symbolic expressions; requires all edge parameters to be defined or assigns random values.
- `savecsv::Bool=false`: If true, saves CFs to a CSV file named `<filename>.csv`.
- `macaulay::Bool=false`: If true, generates a Macaulay2 script (`<filename>.m2`) for symbolic analysis; requires `symbolic=true`.
- `matlab::Bool=false`: If true, generates a MATLAB script (`<filename>.m`) for symbolic analysis; requires `symbolic=true`.
- `multigraded::Bool=false`: If true, generates a Macaulay2 multigraded implicitization script (`<filename>.im.m2.txt`); requires `symbolic=true`.
- `singular::Bool=false`: If true, generates a Singular script (`<filename>.sing`); requires `symbolic=true`.

# Returns
- `quartet::Vector{PhyloNetworks.QuartetT}`: Array of QuartetT objects containing quartet indices, taxa, and CFs (numerical or symbolic).
- `taxa::Vector{String}`: Sorted list of taxon names from the network.

# Throws
- `ErrorException`: If the root is a leaf, edge lengths are missing/negative, γ values are missing/negative, or inheritance correlation is invalid.
- `ErrorException`: If `macaulay`, `matlab`, or `singular` is true but `symbolic` is false.

# Side Effects
- Writes a log file (`<filename>.log`) with topology, parameters, and CFs.
- Optionally writes CSV, Macaulay2, MATLAB, multigraded, or Singular files based on flags.
"""
function network_expectedCF_formulas(network::HybridNetwork; 
                            showprogressbar=false, 
                            inheritancecorrelation=0, 
                            filename="symbolicQNC_HFO_out"::AbstractString,     
                            symbolic=false::Bool,
                            savecsv=false::Bool,
                            macaulay=false::Bool,
                            matlab=false::Bool,
                            multigraded=false::Bool,
                            singular=false::Bool
                            )
    
    #----------filename and logging----------#
    log=string(filename,".log")
    logfile=open(log,"w")
    str="SymbolicQuartetNetworkCoal.jl log\n"
    str*="Timestamp: $(Dates.now())\n"
    str*="------------------------\n"
    write(logfile,str)
    flush(logfile)
    #---------forcing things to work---------#
    str="General setting: \n"
    str*="Symbolic option: "
    if(symbolic) 
        net=deepcopy(network)        
        #check if params all exist otherwise, assign them using readTopologyrand
        params=true
        for e in net.edge
            if e.length<0
                params=false
            end
        end

        if !(params)
            @warn("Input topology is missing some parameters. Assigning arbitrary values using [readTopologyrand]")
            net=readTopologyrand(net)
        else
            net=network
        end

        str*="on\n"
    else
        net=network 
        str*="off\n"
    end
    str*="Store output in .csv file: "
    str*=(savecsv ?  "on\n" : "off\n")
    if(matlab) symbolic || error("symbolic must be set to true.") end
    str*="Write Matlab file: "
    str*=(matlab ? "on\n" : "off\n")
    
    if(macaulay) symbolic || error("symbolic must be set to true.") end
    str*="Write Macaulay2 file: "
    str*=(macaulay ? "on\n" : "off\n")

    write(logfile,str)
    flush(logfile)

    #-----------topologies and dictionary-----------#
    dict=parameterDictionary(net,inheritancecorrelation)
    str="------------------------\n"
    str*="Topology:\n"
    str*="$(writeTopology(net,digits=dpoints))\n"
    if(symbolic) str*="$(gettingSymbolicTopology(net,dict))\n" end
    write(logfile,str)
    flush(logfile)
    
    #-----------setting up desk-----------#
    #need to fix when some parameter values are identical
    df = DataFrame(Split=String[], CF=String[]) 
    str="------------------------\n"
    str*="Parameters:\n"
    str*="Parameter\t\tValue\n"
    for e in net.edge
        str*="$(dict[e.length])\t\t$(e.length)\n"
        if(e.hybrid) str*="$(dict[e.gamma])\t\t$(e.gamma)\n" end
    end
    str*="$(dict[inheritancecorrelation])\t\t$(inheritancecorrelation)\n"
    if symbolic
        write(logfile,str)
        flush(logfile)    
    else
        str=""
        write(logfile,str)
        flush(logfile)    
    end
    
    #--------(almost) original stuff--------#
    net.node[net.root].leaf && error("The root can't be a leaf.")
    PN.check_nonmissing_nonnegative_edgelengths(net,
        "Edge lengths are needed in coalescent units to calcualte expected CFs.")
    all(e.gamma >= 0.0 for e in net.edge) || error("some γ's are missing for hybrid edges: can't calculate expected CFs.")
    inheritancecorrelation >= 0 || error("the inheritance correlation should be non-negative")
    inheritancecorrelation <= 1 || error("the inheritance correlation should be <= 1")
    taxa = sort!(tipLabels(net))
    taxonnumber = Dict(taxa[i] => i for i in eachindex(taxa))
    ntax = length(taxa)
    nCk = PN.nchoose1234(ntax) # matrix to rank 4-taxon sets
    qtype = MVector{3,Float64} # 3 floats: CF12_34, CF13_24, CF14_23; initialized at 0.0
    numq = nCk[ntax+1,4]
    quartet = Vector{PN.QuartetT{qtype}}(undef, numq)
    ts = [1,2,3,4]
    for qi in 1:numq
        quartet[qi] = PN.QuartetT(qi, SVector{4}(ts), MVector(0.,0.,0.))
        # next: find the 4-taxon set with the next rank,
        #       faster than using the direct mapping function
        ind = findfirst(x -> x>1, diff(ts))
        if ind === nothing ind = 4; end
        ts[ind] += 1
        for j in 1:(ind-1)
            ts[j] = j
        end
    end
    if showprogressbar
        nstars = (numq < 50 ? numq : 50)
        nquarnets_perstar = (numq/nstars)
        println("Calculation quartet CFs for $numq quartets...")
        print("0+" * "-"^nstars * "+100%\n  ")
        stars = 0
        nextstar = Integer(ceil(nquarnets_perstar))
    end
    for qi in 1:numq
        network_expectedCF!(quartet[qi], net, taxa, taxonnumber, inheritancecorrelation, df, symbolic, dict)
        if showprogressbar && qi >= nextstar
            print("*")
            stars += 1
            nextstar = Integer(ceil((stars+1) * nquarnets_perstar))
        end
    end
    showprogressbar && print("\n")

    #--------output--------#
    str="------------------------\n"
    str*="Concordance factor:\n"
    str*="Quartet\t\tFormula\n"
    for i in 1:nrow(df)
        str*="$(df[i,1])\t\t$(df[i,2])\n"
    end
    if(savecsv) CSV.write("$filename.csv",df,header=false) end
    write(logfile,str)
    flush(logfile)
    
    #macaulay output
    numCFs=size(df)[1]
    if(symbolic) 
        dataframe=deepcopy(df)
        params=gettingSymbolicInput(net, dataframe, inheritancecorrelation) 
    end
    if(macaulay)
        open("$filename.m2", "w") do file
        str="R = QQ["
        for par in params str=str*par*"," end
        str=str*"C_1..C_$numCFs]\n"
        str=str*"I = ideal(\n"
        i=1
        while i<numCFs
            str=str*"$(dataframe[i,2])-C_$i,\n"
            i+=1
        end
        str=str*"$(dataframe[numCFs,2])-C_$numCFs);\n"
        str=str*"G = eliminate (I, {"
        numparams=length(params)   
        for par in 1:(length(params)-1) str=str*params[par]*"," end
        str=str*"$(params[numparams])})\n"
        str=str*"S = QQ[C_1..C_$numCFs]\nJ = sub(G,S)\ndim J"
        write(file, str)
        end
    end

    #matlab output
    if(matlab)
        open("$filename.m", "w") do file 
            str="% Declare variables\n"
            str=str*"syms "
            for par in params str=str*par*" " end
            for i in 1:numCFs str=str*"C_$i " end
            str=str*"\n\n% matrix of generating polynomials\n"
            str=str*"F=["
            i=1
            while i<numCFs
                str=str*"$(dataframe[i,2])-C_$i,\n"
                i+=1
            end
            str=str*"$(dataframe[numCFs,2])-C_$numCFs];\n"
            str=str*"\n% matrix of generating polynomials\n"
            str=str*"\n% Array of all variables\n"
            str=str*"V=["
            for par in params str=str*par*" " end
            for i in 1:numCFs-1 str=str*"C_$i " end
            str=str*"C_$numCFs]\n"
            str=str*"\n% Compute dimension\nCoalDim(F,V)"
        write(file, str)
        end
    end

    if(multigraded)
        open("$filename.im.m2.txt", "w") do file
        str="needsPackage \"MultigradedImplicitization\"\n"
        str*="R = QQ["
        for par in params str=str*par*"," end
        str*="T]\n"
        str*="S = QQ["
        str=str*"C_0..C_$numCFs]\n"
        str=str*"im = {\n"
        i=1
        while i<numCFs
            str=str*"$(dataframe[i,2]),\n"
            i+=1
        end
        str=str*"$(dataframe[numCFs,2])};\n"

        str=str*"im = {T} | apply(im, f -> f * T);\n"
        str=str*"phi = map(R, S, im)\n"
        str=str*"d=1\n"
        str=str*"I = time componentsOfKernel(d, phi)\n"
        str=str*"L = flatten values I"

        write(file, str)
        end
    end

    if(singular)
        open("$filename.sing", "w") do file
        str="ring R = 0, ("
        for par in params str=str*par*"," end
        for i in 1:numCFs str=str*"C$i," end
        str=chop(str)
        str=str*"), dp;\n"
        str=str*"ideal I = \n"
        i=1
        while i<numCFs
            str=str*"$(dataframe[i,2])-C$i,\n"
            i+=1
        end
        str=str*"$(dataframe[numCFs,2])-C$numCFs;\n"

        str=str*"ideal G = eliminate (I, "
        for par in params str=str*par*"*" end
        str=chop(str)
        str=str*");\n"

        str=str*"ring S = 0, ("
        for i in 1:numCFs str=str*"C$i," end
        str=chop(str)
        str=str*"), dp;\n"
        str=str*"ideal J = imap(R, G);\n"
        str=str*"int dimJ = dim(J);\n"
        str=str*"dimJ;"

        write(file, str)
    end
end

    return quartet, taxa
end


"""
    network_expectedCF!(quartet::QuartetT, net::HybridNetwork, taxa, taxonnumber,
            inheritancecorrelation)

Update `quartet.data` to contain the quartet concordance factors expected from
the multispecies coalescent along network `net` for the 4-taxon set `taxa[quartet.taxonnumber]`.
`taxa` should contain the tip labels in `net`. `quartet.taxonnumber` gives the
indices in `taxa` of the 4 taxa of interest. `taxonnumber` should be a dictionary
mapping taxon labels in to their indices in `taxa`, for easier lookup.

`net` is not modified.

For `inheritancecorrelation` see [`network_expectedCF`](@ref).
Its value should be between 0 and 1 (not checked by this internal function).
"""
function network_expectedCF!(quartet::PN.QuartetT{MVector{3,Float64}},
                                net::HybridNetwork, 
                                taxa, 
                                taxonnumber, 
                                inheritancecorrelation, 
                                df,
                                symbolic,
                                dict)
    #create an array that stores the CF formulas for ab|cd, ac|bd, ad|bc
    qCFp=String["","",""] 

    net = deepcopy(net)
    PN.removedegree2nodes!(net)
    # delete all taxa except for the 4 in the quartet
    for taxon in taxa
        taxonnumber[taxon] in quartet.taxonnumber && continue
        deleteleaf!(net, taxon, simplify=false, unroot=false)
        # would like unroot=true but deleteleaf! throws an error when the root is connected to 2 outgoing hybrid edges
    end

    #PN.printEverything(net)
    #dict=parameterDictionary(net,inheritancecorrelation)
    
    q,qCFp=network_expectedCF_4taxa!(net, taxa[quartet.taxonnumber], inheritancecorrelation, qCFp, dict, symbolic)
    quartet.data .= q

    #storing the equations to DataFrames
    for i in 1:3
        qCFp[i]=replace(qCFp[i], "&"=>"")
        qCFp[i]=filter(x -> !isspace(x), qCFp[i])
    end

    f=taxa[quartet.taxonnumber]
    push!(df, ("$(f[1])$(f[2])|$(f[3])$(f[4])", "$(qCFp[1])"))
    push!(df, ("$(f[1])$(f[3])|$(f[2])$(f[4])", "$(qCFp[2])"))         
    push!(df, ("$(f[1])$(f[4])|$(f[2])$(f[3])", "$(qCFp[3])"))
    
    return quartet
end

"""
    network_expectedCF_4taxa!(net::HybridNetwork, fourtaxa, inheritancecorrelation)

Return the quartet concordance factors expected from the multispecies coalescent
along network `net`, where the 3 quartet topologies are ordered following the
ordering of taxon names in `fourtaxa`, that is: if `fourtaxa` is a,b,c,d,
then the concordance factors are listed in this order:

    (qCF(ab|cd), qCF(ac|bd), qCF(ad,bc))

Assumptions about `net`:
- has 4 taxa, and those are the same as `fourtaxa`
- no degree-2 nodes, except perhaps for the root
- edge lengths are non-missing
- hybrid edge γ's are non-missing

The network is modified as follows: what's above the LSA is removed,
the 2 edges incident to the root are fused (if the root is of degree 2),
and external degree-2 blobs are removed. `net` is then simplified recursively
by removing hybrid edges for the recursive calculation of qCFs.

For `inheritancecorrelation` see [`network_expectedCF`](@ref).
Its value should be between 0 and 1 (not checked by this internal function).
"""
function network_expectedCF_4taxa!(net::HybridNetwork, fourtaxa, inheritancecorrelation, qCFp, dict, symbolic)
    
    #kong: begin writing qCF equations  with an opening bracket
    qCFp .*= "(" 
    
    deleteaboveLSA!(net)
    # make sure the root is of degree 3+
    if length(net.node[net.root].edge) <= 2
        PN.fuseedgesat!(net.root, net)
    end
    # find and delete degree-2 blobs along external edges
    bcc = biconnectedComponents(net, true) # true: ignore trivial blobs
    entry = PN.biconnectedcomponent_entrynodes(net, bcc)
    entryindex = indexin(entry, net.nodes_changed)
    exitnodes = PN.biconnectedcomponent_exitnodes(net, bcc, false) # don't redo the preordering
    bloborder = sortperm(entryindex) # pre-ordering for blobs in their own blob tree
    function isexternal(ib) # is bcc[ib] of degree 2 and adjacent to an external edge?
        # yes if: 1 single exit adjacent to a leaf
        length(exitnodes[ib]) != 1 && return false
        ch = PN.getchildren(exitnodes[ib][1])
        return length(ch) == 1 && ch[1].leaf
    end
    for ib in reverse(bloborder)
        isexternal(ib) || continue # keep bcc[ib] if not external of degree 2
        for he in bcc[ib]
            he.isMajor && continue
            # deletion of a hybrid can hide the deletion of another: check that he is still in net
            any(e -> e===he, net.edge) || continue
            # delete minor hybrid edge with options unroot=true: to make sure the
            # root remains of degree 3+, in case a degree-2 blob starts at the root
            # simplify=true: bc external blob
            PN.deletehybridedge!(net,he, false,true,false,true,false)
        end
    end
    ndes = 4 # number of taxa descendant from lowest hybrid node
    if net.numHybrids > 0
        preorder!(net)
        # find a lowest hybrid node and # of taxa below it
        hyb = net.nodes_changed[findlast(n -> n.hybrid, net.nodes_changed)]
        #funneledge = [e for e in hyb.edge if getparent(e) === hyb]
        funneledge = [e for e in hyb.edge if PhyloNetworks.getparent(e) === hyb]
        ispolytomy = length(funneledge) > 1
        funneldescendants = union([PN.descendants(e) for e in funneledge]...)
        ndes = length(funneldescendants)
        #n2 = (ispolytomy ? hyb : getchild(funneledge[1]))
        n2 = (ispolytomy ? hyb : PhyloNetworks.getchild(funneledge[1]))
        ndes > 2 && n2.leaf && error("2+ descendants below the lowest hybrid, yet n2 is a leaf. taxa: $(fourtaxa)")
    end
    if ndes > 2 # simple formula for qCF: find cut edge and its length
        # inheritance correlation has no impact
        # pool of cut edges below. contains NO external edge, bc n2 not leaf (if reticulation), nice tree ow
        cutpool = (net.numHybrids == 0 ? net.edge :
                    [e for e in n2.edge if PN.getparent(e) === n2])
        #filter!(e -> !getchild(e).leaf, cutpool)
        filter!(e -> !PhyloNetworks.getchild(e).leaf, cutpool)
        net.numHybrids > 0 || length(cutpool) <= 1 ||
            error("2+ cut edges, yet 4-taxon tree, degree-3 root and no degree-2 nodes. taxa: $(fourtaxa)")
        sistertofirst = 2    # arbitrarily correct if 3-way polytomy (no cut edge)
        internallength = 0.0 # correct if polytomy
        internallengthbinary = ""
        for e in cutpool
            length(cutpool) < 3 || println("more than 2 edged merged")
            internallength += e.length
            internallengthbinary=binary(e.number,internallengthbinary)
            hwc = hardwiredCluster(e, fourtaxa)
            sistertofirst = findnext(x -> x == hwc[1], hwc, 2)
        end

        minorcf = exp(-internallength)/3
        majorcf = 1.0 - 2 * minorcf
        qCF = (sistertofirst == 2 ? MVector{3,Float64}(majorcf,minorcf,minorcf) :
              (sistertofirst == 3 ? MVector{3,Float64}(minorcf,majorcf,minorcf) :
                                    MVector{3,Float64}(minorcf,minorcf,majorcf) ))
        
        #writing out the equations
        internallength=round(internallength, digits = dpoints)
        if symbolic
            #minorcfp = "exp(-$(dict[internallength]))/3"
            minorcfp = "exp(-$(binary_to_tstring(internallengthbinary)))/3"
            majorcfp = "1-2*$minorcfp"
        else
            minorcfp = "exp(-$internallength)/3"
            majorcfp = "1-2*$minorcfp"
        end
        #=to be added to symbolic=#
        (sistertofirst == 2 ? (qCFp[1]*="$majorcfp",qCFp[2]*="$minorcfp",qCFp[3]*="$minorcfp") :
        (sistertofirst == 3 ? (qCFp[1]*="$minorcfp",qCFp[2]*="$majorcfp",qCFp[3]*="$minorcfp") :
                              (qCFp[1]*="$minorcfp",qCFp[2]*="$minorcfp",qCFp[3]*="$majorcfp") ))                      
        qCFp .*= ")" #kong: end qCF with an closing bracket
        
        return qCF, qCFp
    end

    ndes > 0 || error("weird: hybrid node has no descendant taxa")
    # by now, there are 1 or 2 taxa below the lowest hybrid
    qCF = MVector{3,Float64}(0.0,0.0,0.0) # mutated later
    #parenthedge = [e for e in hyb.edge if getchild(e) === hyb]
    parenthedge = [e for e in hyb.edge if PhyloNetworks.getchild(e) === hyb]
    all(h.hybrid for h in parenthedge) || error("hybrid $(hyb.number) has a parent edge that's a tree edge")
    parenthnumber = [p.number for p in parenthedge]
    nhe = length(parenthedge)
    if ndes == 1 # weighted qCFs average of the nhe (often = 2) displayed networks
        # inheritance correlation has no impact
        for i in 1:nhe # keep parenthedge[i], remove all others
            # kong: add + if there are more than a single element
            if i>1 qCFp .*= "+" end
            
            gamma = parenthedge[i].gamma
            simplernet = ( i < nhe ? deepcopy(net) : net ) # last case: to save memory allocation
            for j in 1:nhe
                j == i && continue # don't delete hybrid edge i!
                pe_index = findfirst(e -> e.number == parenthnumber[j], simplernet.edge)
                PN.deletehybridedge!(simplernet, simplernet.edge[pe_index],
                    false,true,false,false,false) # ., unroot=true, ., simplify=false,.
            end
            qCF0,qCFp = network_expectedCF_4taxa!(simplernet, fourtaxa, inheritancecorrelation,qCFp,dict,symbolic)
            qCF .+= gamma .* qCF0
            
            #kong: writing gamma into qCF equations
            if symbolic qCFp .*= "*$(dict[gamma])" 
            else qCFp .*= "*$gamma" end
        end
        
        #kong: closing qCFq with a bracket
        qCFp .*= ")"

        return qCF, qCFp
    end

    # by now: 2 descendant below the lowest hybrid node: hardest case
    # weighted qCFs average of 3 networks: 2 displayed, 1 "parental" (unless same parents)
    sameparents = (inheritancecorrelation == 1)

    oneminusrho = 1 - inheritancecorrelation

    if symbolic 
        oneminusrhop="1-$(dict[inheritancecorrelation])"
    else
        oneminusrhop="1-$inheritancecorrelation"
    end

    hwc = hardwiredCluster(parenthedge[1], fourtaxa)
    sistertofirst = findnext(x -> x == hwc[1], hwc, 2)
    internallength = ( ispolytomy ? 0.0 : funneledge[1].length)
    deepcoalprob = exp(-internallength)
    deepcoalprob=round(deepcoalprob, digits = dpoints)
    internallength=round(internallength, digits = dpoints)
    #internallengthbinary = binary(funneledge[1].number,"")
    internallengthbinary =  ( ispolytomy ? "0.0" : binary(funneledge[1].number,"")) 
    if symbolic deepcoalprobp="exp(-$internallength)" end
    #if symbolic deepcoalprobp = "exp(-$(binary_to_tstring(binary(funneledge[1].number, internallengthbinary))))" end

    # initialize qCF: when the 2 descendants coalesce before reaching the hybrid node
    qCF = (sistertofirst == 2 ? MVector{3,Float64}(1.0-deepcoalprob,0.0,0.0) :
          (sistertofirst == 3 ? MVector{3,Float64}(0.0,1.0-deepcoalprob,0.0) :
                                MVector{3,Float64}(0.0,0.0,1.0-deepcoalprob) ))

    #if symbolic deepcoalprobp = "exp(-$(dict[internallength]))" 
    if symbolic 
        if internallengthbinary!=="0.0"
            deepcoalprobp = "exp(-$(binary_to_tstring(internallengthbinary)))" 
        end
        #println("exp(-$(binary_to_tstring(internallengthbinary)))" )
    else deepcoalprobp = "exp(-$internallength)" end
    
    (sistertofirst == 2 ? (qCFp[1]*="(1-$deepcoalprobp)+",qCFp[2]*="",qCFp[3]*="") :
    (sistertofirst == 3 ? (qCFp[1]*="",qCFp[2]*="(1-$deepcoalprobp)+",qCFp[3]*="") :
                        (qCFp[1]*="",qCFp[2]*="",qCFp[3]*="(1-$deepcoalprobp)+") ))                                     
    qCFp .*= ""

    # no coalescence on cut-edge: delete it and extract parental networks
    ispolytomy || PN.shrinkedge!(net, funneledge[1])
    # shrinkedge! requires PhyloNetworks v0.15.2
    childedge = [e for e in hyb.edge if PN.getparent(e) === hyb]
    length(childedge) == 2 ||
      error("2-taxon subtree, but not 2 child edges after shrinking the cut edge.")
    all(PN.getchild(e).leaf for e in childedge) ||
      error("2-taxon subtree, cut-edge shrunk, but the 2 edges aren't both external")
    childnumber = [e.number for e in childedge]
    for i in 1:nhe
      pgam=parenthedge[i].gamma
      weighti = deepcoalprob * pgam
      #kong: round weighti to n digits
      weighti=round(weighti, digits = dpoints)
      
      for j in (sameparents ? i : 1):i # if inheritancecorrelation=1 then i!=j has probability 0
        gammaj = parenthedge[j].gamma
        #kong: round gammaj to n digits
        gammaj=round(gammaj, digits = dpoints)

        simplernet = ( i < nhe || j < nhe ? deepcopy(net) : net )
        # delete all hybedges other than i & j
        for k in 1:nhe
            (k == i || k ==j) && continue # don't delete hybrid edges i or j
            pe_index = findfirst(e -> e.number == parenthnumber[k], simplernet.edge)
            PN.deletehybridedge!(simplernet, simplernet.edge[pe_index],false,true,false,false,false) # ., unroot=true,., simplify=false,.
        end
        if i != j
            # detach childedge[2] from hyb and attach it to hyb's parent j
            pej_index = findfirst(e -> e.number == parenthnumber[j], simplernet.edge)
            pej = simplernet.edge[pej_index]
            pn = PN.getparent(pej)
            hn = PN.getchild(pej) # hyb node, but in simplernet
            ce2_index = findfirst(e -> e.number == childnumber[2], simplernet.edge)
            ce2 = simplernet.edge[ce2_index]
            PN.removeEdge!(hn,ce2)
            hn_index = findfirst(x -> x === hn, ce2.node)
            ce2.node[hn_index] = pn # ce2.isChild1 remains synchronized
            push!(pn.edge, ce2)
            # then delete hybedge j
            PN.deletehybridedge!(simplernet, pej, false,true,false,false,false) # ., unroot=true,., simplify=false,.)
            for e in simplernet.edge
                e.length=round(e.length, digits = dpoints)
            end
        end
        #kong: add "+" if there are more than a single element in the equation
        if i>1 qCFp .*= "+" end
        #initialize qCFp for qCF_subnet
        qCFps=["","",""]
        qCF_subnet, qCFps = network_expectedCF_4taxa!(simplernet, fourtaxa, inheritancecorrelation, qCFps, dict,symbolic)
        if i == j
            prob = weighti * (gammaj * oneminusrho + inheritancecorrelation)
            prob=round(prob, digits = dpoints)

            qCF .+= prob .* qCF_subnet
           
        if symbolic
            for i in 1:3
                qCFp[i] *= "((($deepcoalprobp * $(dict[pgam])) * ($(dict[gammaj]) * $(dict[oneminusrho]) + $(dict[inheritancecorrelation]))) * ($(qCFps[i])))"
            end
        else
            for i in 1:3
                qCFp[i] *= "((($deepcoalprobp * $pgam) * ($gammaj * $oneminusrhop + $inheritancecorrelation)) * ($(qCFps[i])))"
            end
        end
        else # add subnetwork with flipped assignment of the 2 taxa to parents i & j
            flipped_ij = (sistertofirst == 2 ? [1,3,2] :
                         (sistertofirst == 3 ? [3,2,1] : [2,1,3] ))
            prob = weighti * gammaj * oneminusrho
            prob=round(prob, digits = dpoints)

            qCF .+= prob .* (qCF_subnet .+ qCF_subnet[flipped_ij])
    
        if symbolic
            for i in 1:3
                qCFp[i] *= "((($deepcoalprobp * $(dict[pgam])) * $(dict[gammaj]) * $(dict[oneminusrho])) * ($(qCFps[i])+$(qCFps[flipped_ij[i]])))"
            end
        else
            for i in 1:3
                qCFp[i] *= "((($deepcoalprobp * $pgam) * $gammaj * $oneminusrhop) * ($(qCFps[i])+$(qCFps[flipped_ij[i]])))"
            end
        end
        end
      end
    end
    
    qCFp .*= ")"
    
    return qCF, qCFp
end